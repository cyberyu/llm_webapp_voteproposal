<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Peer Analysis</title>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0"></script>
    <style>
        body { font-family: Arial, sans-serif; background: #f9f9f9; margin: 0; padding-top: 60px; }
        /* Navigation Bar */
        .navbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #2c3e50;
            padding: 15px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            z-index: 1000;
        }
        .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            gap: 30px;
            padding: 0 20px;
        }
        .nav-brand {
            color: #ecf0f1;
            font-size: 18px;
            font-weight: bold;
            text-decoration: none;
        }
        .nav-links {
            display: flex;
            gap: 20px;
            list-style: none;
            margin: 0;
            padding: 0;
        }
        .nav-links a {
            color: #bdc3c7;
            text-decoration: none;
            padding: 8px 16px;
            border-radius: 4px;
            transition: all 0.3s ease;
        }
        .nav-links a:hover {
            background: #34495e;
            color: #ecf0f1;
        }
        .nav-links a.active {
            background: #3498db;
            color: white;
            cursor: default;
        }
        /* Main content styles */
        .main-content {
            display: flex;
            gap: 24px;
            max-width: 1400px;
            margin: 32px auto;
        }
        .left-panel {
            flex: 0 0 55%;
            max-width: 55%;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.1);
            padding: 32px;
        }
        .right-panel {
            flex: 1;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.1);
            padding: 32px;
            min-height: 600px;
        }
        .container { 
            max-width: 1200px; 
            margin: 32px auto; 
            background: #fff; 
            border-radius: 8px; 
            box-shadow: 0 2px 12px rgba(0,0,0,0.1); 
            padding: 32px; 
        }
        h2 { margin-top: 0; color: #2c3e50; }
        .upload-section {
            margin-bottom: 24px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 6px;
            border: 2px dashed #dee2e6;
        }
        .upload-section input[type="file"] {
            margin-bottom: 12px;
            padding: 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            background: white;
        }
        .btn {
            padding: 10px 20px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
        }
        .btn:hover {
            background: #2980b9;
        }
        .btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }
        #tableContainer {
            overflow: auto;
            max-height: 600px;
            max-width: 100%;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            background: #ffffff;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        #largeTableContainer {
            overflow: auto;
            max-height: 600px;
            max-width: 100%;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            background: #ffffff;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-top: 16px;
        }
        table {
            border-collapse: collapse;
            width: auto;
            min-width: 400px;
            max-width: 900px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #largeTableContainer table {
            border-collapse: collapse;
            width: auto;
            min-width: 400px;
            max-width: 900px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        th, td {
            border: 1px solid #dee2e6;
            padding: 10px 14px;
            text-align: left;
            font-size: 13px;
            vertical-align: top;
        }
        th {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
            color: #495057;
            text-transform: uppercase;
            font-size: 11px;
            letter-spacing: 0.5px;
        }
        tr:nth-child(even) {
            background: #f8f9fa;
        }
        tr:hover {
            background: #e3f2fd;
            transition: background-color 0.2s ease;
        }
        /* Special styling for proposal column */
        .proposal-cell {
            max-width: 600px;
            min-width: 400px;
            word-wrap: break-word;
            white-space: normal;
            line-height: 1.4;
        }
        .proposal-header {
            min-width: 400px;
        }
        /* Other important columns */
        .category-cell {
            min-width: 120px;
            font-weight: 500;
        }
        .issuer-cell {
            min-width: 100px;
            font-weight: 500;
        }
        .numeric-cell {
            text-align: right;
            font-family: 'Courier New', monospace;
            min-width: 80px;
        }
        .no-data {
            color: #6c757d;
            text-align: center;
            padding: 40px;
            font-style: italic;
        }
        .file-info {
            margin-bottom: 16px;
            padding: 12px;
            background: #d4edda;
            border: 1px solid #c3e6cb;
            border-radius: 4px;
            color: #155724;
        }
        .filter-info {
            margin-bottom: 16px;
            padding: 12px;
            background: #cce5ff;
            border: 1px solid #99ccff;
            border-radius: 4px;
            color: #004085;
            display: none;
        }
        .error-message {
            margin-bottom: 16px;
            padding: 12px;
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            border-radius: 4px;
            color: #721c24;
        }
        #chartContainer {
            margin-top: 24px;
            height: 900px; /* enlarged */
            position: relative;
        }
        #issuerChartContainer {
            margin-top: 24px;
            height: 900px; /* enlarged */
            position: relative;
        }
        #comparisonChartContainer {
            margin-top: 24px;
            height: 1100px; /* enlarged */
            position: relative;
        }
        .chart-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 16px;
            color: #2c3e50;
            text-align: center;
        }
        .chart-instructions {
            font-size: 12px;
            color: #6c757d;
            text-align: center;
            margin-bottom: 12px;
            font-style: italic;
        }
        .filter-controls {
            text-align: center;
            margin-bottom: 16px;
        }
        .filter-btn {
            padding: 6px 12px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-right: 8px;
            margin-bottom: 8px;
        }
        .filter-btn:hover {
            background: #218838;
        }
        .filter-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        .export-btn {
            padding: 8px 16px;
            background: #17a2b8;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            margin-left: 10px;
            border: 1px solid #17a2b8;
            transition: all 0.3s ease;
        }
        .export-btn:hover {
            background: #138496;
            border-color: #117a8b;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .button-group {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }
        .sort-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        /* Responsive styles */
        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
                gap: 16px;
            }
            .left-panel, .right-panel {
                flex: 1 1 100%;
                max-width: 100%;
            }
            .nav-container {
                flex-direction: column;
                align-items: flex-start;
                gap: 16px;
            }
            .nav-brand {
                font-size: 16px;
            }
            .nav-links {
                flex-direction: column;
                width: 100%;
                align-items: flex-start;
            }
            .nav-links a {
                padding: 10px 15px;
                width: 100%;
                text-align: left;
            }
            .btn {
                width: 100%;
                padding: 12px;
                font-size: 16px;
            }
            .filter-btn, .export-btn {
                width: auto;
                flex: 1 1 100%;
                margin: 4px 0;
            }
            .button-group {
                flex-direction: column;
                width: 100%;
            }
            .sort-buttons {
                width: 100%;
                justify-content: space-between;
            }
        }
    </style>
</head>
<body>
    <!-- Navigation Bar -->
    <nav class="navbar">
        <div class="nav-container">
            <a href="#" class="nav-brand">LLM WebApp</a>
            <ul class="nav-links">
                <li><a href="webui.html">Main Table</a></li>
                <li><a href="detail.html">Detail Viewer</a></li>
                <li><a href="histrogram.html">Histogram Analyzer</a></li>
                <li><a href="peeranalysis.html" class="active">Peer Analysis</a></li>
            </ul>
        </div>
    </nav>

    <div class="main-content">
        <div class="left-panel">
            <h2>Peer Analysis</h2>
            
            <div class="upload-section">
                <h3>Upload CSV File</h3>
                <input type="file" id="csvInput" accept=".csv">
                <br>
                <button class="btn" id="loadBtn" disabled>Load & Display Data</button>
                <button class="btn" id="loadDefaultBtn">Load Default File</button>
                <button class="btn" id="clearBtn" disabled>Clear Data</button>
            </div>

            <!-- Issuer Filter Dropdown for Peer Analysis -->
            <div id="issuer-filter-container-peer" class="filter-controls" style="margin-bottom: 16px; display: none; text-align: left;">
                <label for="issuerDropdownPeer" style="font-weight: 500; margin-right: 8px;">Filter by Issuer (Peer):</label>
                <select id="issuerDropdownPeer" style="padding: 6px; border: 1px solid #ced4da; border-radius: 4px; min-width: 220px;">
                    <option value="">All Issuers</option>
                </select>
            </div>

            <div id="fileInfo"></div>
            <div id="filterInfo"></div>
            <div id="errorMessage"></div>

            <div id="tableContainer">
                <div class="no-data">No CSV file loaded. Please upload a file to begin analysis.</div>
            </div>
            
            <!-- Large Dataset Section -->
            <div class="large-dataset-section" style="margin-top: 40px;">
                <h3>Large Dataset Viewer</h3>
                <div class="upload-section">
                    <h4>Upload Large CSV File (35k+ rows)</h4>
                    <input type="file" id="largeCsvInput" accept=".csv">
                    <br>
                    <button class="btn" id="loadLargeBtn" disabled>Load Large Dataset</button>
                    <button class="btn" id="loadDefaultLargeBtn">Load Default File</button>
                    <button class="btn" id="clearLargeBtn" disabled>Clear Large Dataset</button>
                </div>

                <!-- Issuer Filter Dropdown for Large Dataset -->
                <div id="issuer-filter-container-large" class="filter-controls" style="margin-bottom: 16px; display: none; text-align: left;">
                    <label for="issuerDropdownLarge" style="font-weight: 500; margin-right: 8px;">Filter by Issuer (Large):</label>
                    <select id="issuerDropdownLarge" style="padding: 6px; border: 1px solid #ced4da; border-radius: 4px; min-width: 220px;">
                        <option value="">All Issuers</option>
                    </select>
                </div>

                <div id="largeFileInfo"></div>
                <div id="largeErrorMessage"></div>

                <div id="largeTableContainer">
                    <div class="no-data">No large CSV file loaded. Upload a file to view top 100 rows with synchronized filtering.</div>
                </div>
                
                <!-- Show Summary Button and Summary Box -->
                <div style="margin-top: 16px;">
                    <button class="btn" id="showSummaryBtn" disabled>Show Summary</button>
                </div>

                <div id="summaryBox" style="margin: 16px 0; padding: 16px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 6px; font-size: 14px; color: #333; white-space: pre-line; display: none;">
                </div>
            </div>
        </div>

        <div class="right-panel">
            <div class="chart-title">Category Distribution</div>
            <div class="chart-instructions">Click on bars to filter table data, click outside bars to show all</div>
            <div class="filter-controls">
                <button class="filter-btn" id="showAllBtn" disabled>Show All Data</button>
            </div>
            <div id="chartContainer">
                <div class="no-chart">Upload and load a CSV file to see category distribution</div>
            </div>
            
            <div class="chart-title" style="margin-top: 40px;">Issuer Distribution</div>
            <div class="chart-instructions">Click on bars to filter table data, click outside bars to show all</div>
            <div class="filter-controls">
                <button class="filter-btn" id="showAllIssuerBtn" disabled>Show All Data</button>
            </div>
            <div id="issuerChartContainer">
                <div class="no-chart">Upload and load a CSV file to see issuer distribution</div>
            </div>
            
            <div class="chart-title" id="comparisonChartTitle" style="margin-top: 40px;">Issuer Proposal Comparison</div>
            <div class="chart-instructions">Stacked bars showing rejected (ForRatio < 0.5) vs approved (ForRatio >= 0.5) counts by issuer</div>
            <div class="filter-controls">
                <label style="display: flex; align-items: center; gap: 8px; font-size: 14px; color: #2c3e50;">
                    <input type="checkbox" id="mgmtProposalFilter" style="margin: 0;">
                    Show management proposal only
                </label>
                <div class="button-group">
                    <div class="sort-buttons">
                        <button class="filter-btn" id="sortByTotalBtn">Sort by Total Count</button>
                        <button class="filter-btn" id="sortByRejectedBtn">Sort by Rejected Count</button>
                        <button class="filter-btn" id="sortByRejectedPctBtn">Sort by Rejected Pct</button>
                    </div>
                    <button class="export-btn" id="exportIssuerNamesBtn">
                        ðŸ“‹ Export Issuer Names
                    </button>
                </div>
            </div>
            <div id="comparisonChartContainer">
                <div class="no-chart">Upload both datasets to see issuer proposal comparison</div>
            </div>
        </div>
    </div>

    <script>        let csvData = [];
        let headers = [];
        let categoryChart = null;
        let issuerChart = null;
        let comparisonChart = null;
        let filteredData = [];
        let categoryCol = null;
        let subcategoryCol = null;
        let issuerCol = null;
        let selectedCategoryIndex = -1;
        let selectedIssuerIndex = -1;

        // Large dataset variables
        let largeCsvData = [];
        let largeHeaders = [];
        let largeFilteredData = [];
        let largeCategoryCol = null;
        let largeSubcategoryCol = null;
        let largeIssuerCol = null;

        // Debouncing for chart regeneration
        let chartRegenerationTimeout = null;

        // File input change handler
        document.getElementById('csvInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) {
                document.getElementById('loadBtn').disabled = true;
                return;
            }

            // Enable load button when file is selected
            document.getElementById('loadBtn').disabled = false;
            
            // Clear previous messages
            document.getElementById('fileInfo').innerHTML = '';
            document.getElementById('errorMessage').innerHTML = '';
        });

        // Large CSV file input change handler
        document.getElementById('largeCsvInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) {
                document.getElementById('loadLargeBtn').disabled = true;
                return;
            }

            // Enable load button when file is selected
            document.getElementById('loadLargeBtn').disabled = false;
            
            // Clear previous messages
            document.getElementById('largeFileInfo').innerHTML = '';
            document.getElementById('largeErrorMessage').innerHTML = '';
        });

        // Load button click handler
        document.getElementById('loadBtn').addEventListener('click', function() {
            const fileInput = document.getElementById('csvInput');
            const file = fileInput.files[0];
            
            if (!file) {
                showError('Please select a CSV file first.');
                return;
            }

            // Show loading state
            this.disabled = true;
            this.textContent = 'Loading...';

            // Parse CSV file
            Papa.parse(file, {
                header: true,
                skipEmptyLines: true,
                complete: function(results) {
                    if (results.errors.length > 0) {
                        showError('Error parsing CSV: ' + results.errors[0].message);
                        document.getElementById('loadBtn').disabled = false;
                        document.getElementById('loadBtn').textContent = 'Load & Display Data';
                        return;
                    }

                    csvData = results.data;
                    headers = results.meta.fields;
                    
                    if (csvData.length === 0) {
                        showError('The CSV file appears to be empty or contains no valid data.');
                        document.getElementById('loadBtn').disabled = false;
                        document.getElementById('loadBtn').textContent = 'Load & Display Data';
                        return;
                    }

                    // Show file info
                    showFileInfo(file.name, csvData.length, headers.length);
                    
                    // Initialize filtered data to show all data
                    filteredData = [...csvData];
                    
                    // Render table
                    renderFilteredTable();
                    
                    // Generate and display chart
                    generateCategoryChart();
                    
                    // Generate and display issuer chart
                    generateIssuerChart();
                    
                    // Generate comparison chart if large dataset is available
                    generateComparisonChart();
                    
                    // Update button states
                    document.getElementById('loadBtn').disabled = false;
                    document.getElementById('loadBtn').textContent = 'Load & Display Data';
                    document.getElementById('clearBtn').disabled = false;
                    document.getElementById('showAllBtn').disabled = false;
                    document.getElementById('showAllIssuerBtn').disabled = false;
                },
                error: function(error) {
                    showError('Failed to read CSV file: ' + error.message);
                    document.getElementById('loadBtn').disabled = false;
                    document.getElementById('loadBtn').textContent = 'Load & Display Data';
                }
            });
        });

        // Show All button click handler
        document.getElementById('showAllBtn').addEventListener('click', function() {
            showAllRows();
        });

        // Show All Issuer button click handler
        document.getElementById('showAllIssuerBtn').addEventListener('click', function() {
            showAllRows();
        });

        // Management proposal filter checkbox handler
        document.getElementById('mgmtProposalFilter').addEventListener('change', function() {
            // Regenerate comparison chart with new filter setting
            generateComparisonChart();
        });

        // Large dataset load button click handler
        document.getElementById('loadLargeBtn').addEventListener('click', function() {
            const fileInput = document.getElementById('largeCsvInput');
            const file = fileInput.files[0];
            
            if (!file) {
                showLargeError('Please select a CSV file first.');
                return;
            }

            // Show loading state
            this.disabled = true;
            this.textContent = 'Loading...';

            // Parse CSV file
            Papa.parse(file, {
                header: true,
                skipEmptyLines: true,
                complete: function(results) {
                    if (results.errors.length > 0) {
                        showLargeError('Error parsing CSV: ' + results.errors[0].message);
                        document.getElementById('loadLargeBtn').disabled = false;
                        document.getElementById('loadLargeBtn').textContent = 'Load Large Dataset';
                        return;
                    }

                    largeCsvData = results.data;
                    largeHeaders = results.meta.fields;
                    
                    if (largeCsvData.length === 0) {
                        showLargeError('The CSV file appears to be empty or contains no valid data.');
                        document.getElementById('loadLargeBtn').disabled = false;
                        document.getElementById('loadLargeBtn').textContent = 'Load Large Dataset';
                        return;
                    }

                    // Show file info
                    showLargeFileInfo(file.name, largeCsvData.length, largeHeaders.length);
                    
                    // Initialize filtered data to show all data
                    largeFilteredData = [...largeCsvData];
                    
                    // Find columns for filtering
                    largeCategoryCol = largeHeaders.find(h => h.toLowerCase().includes('category') && !h.toLowerCase().includes('sub')) || null;
                    largeSubcategoryCol = largeHeaders.find(h => h.toLowerCase().includes('subcategory') || h.toLowerCase().includes('sub')) || null;
                    largeIssuerCol = largeHeaders.find(h => h.toLowerCase().includes('issuer') || h.toLowerCase().includes('company') || h.toLowerCase().includes('firm')) || null;
                    
                    // Render table (top 100 rows)
                    renderLargeFilteredTable();
                    
                    // Apply current filters if any exist
                    if (window.selectedCategoryKey || window.selectedIssuerKey) {
                        applyFiltersToLargeDataset();
                    }
                    
                    // Generate comparison chart if rejected dataset is available
                    generateComparisonChart();
                    
                    // Update button states
                    document.getElementById('loadLargeBtn').disabled = false;
                    document.getElementById('loadLargeBtn').textContent = 'Load Large Dataset';
                    document.getElementById('clearLargeBtn').disabled = false;
                    updateShowSummaryButton();
                },
                error: function(error) {
                    showLargeError('Failed to read CSV file: ' + error.message);
                    document.getElementById('loadLargeBtn').disabled = false;
                    document.getElementById('loadLargeBtn').textContent = 'Load Large Dataset';
                }
            });
        });

        // Clear large dataset button click handler
        document.getElementById('clearLargeBtn').addEventListener('click', function() {
            largeCsvData = [];
            largeHeaders = [];
            largeFilteredData = [];
            largeCategoryCol = null;
            largeSubcategoryCol = null;
            largeIssuerCol = null;
            document.getElementById('largeTableContainer').innerHTML = '<div class="no-data">No large CSV file loaded. Upload a file to view top 100 rows with synchronized filtering.</div>';
            document.getElementById('largeFileInfo').innerHTML = '';
            document.getElementById('largeErrorMessage').innerHTML = '';
            document.getElementById('largeCsvInput').value = '';
            document.getElementById('loadLargeBtn').disabled = true;
            document.getElementById('clearLargeBtn').disabled = true;
            document.getElementById('summaryBox').style.display = 'none';
            updateShowSummaryButton();
            
            // Regenerate comparison chart
            generateComparisonChart();
        });

        // Clear button click handler
        document.getElementById('clearBtn').addEventListener('click', function() {
            csvData = [];
            headers = [];
            filteredData = [];
            categoryCol = null;
            subcategoryCol = null;
            issuerCol = null;
            selectedCategoryIndex = -1;
            selectedIssuerIndex = -1;
            document.getElementById('tableContainer').innerHTML = '<div class="no-data">No CSV file loaded. Please upload a file to begin analysis.</div>';
            document.getElementById('fileInfo').innerHTML = '';
            hideFilterInfo();
            document.getElementById('errorMessage').innerHTML = '';
            document.getElementById('csvInput').value = '';
            document.getElementById('loadBtn').disabled = true;
            document.getElementById('clearBtn').disabled = true;
            document.getElementById('showAllBtn').disabled = true;
            document.getElementById('showAllIssuerBtn').disabled = true;
            
            // Clear chart
            categoryChart = safeDestroyChart(categoryChart);
            issuerChart = safeDestroyChart(issuerChart);
            comparisonChart = safeDestroyChart(comparisonChart);
            document.getElementById('chartContainer').innerHTML = '<div class="no-chart">Upload and load a CSV file to see category distribution</div>';
            document.getElementById('issuerChartContainer').innerHTML = '<div class="no-chart">Upload and load a CSV file to see issuer distribution</div>';
            document.getElementById('comparisonChartContainer').innerHTML = '<div class="no-chart">Upload both datasets to see issuer proposal comparison</div>';
        });

        // Show Summary button click handler
        document.getElementById('showSummaryBtn').addEventListener('click', function() {
            const summaryBox = document.getElementById('summaryBox');
            const peerDropdown = document.getElementById('issuerDropdownPeer');
            const selectedIssuer = peerDropdown ? peerDropdown.value : '';
            
            // Get record dates, services, mgmt recommendations, and approval rates for the selected issuer from both datasets
            let allRecordDates = [];
            let allServices = [];
            let allMgmtRecs = [];
            let peerApprovalRates = [];
            let largeApprovedRates = [];
            
            // Check peer analysis dataset for record dates and approval rates
            if (csvData.length > 0 && issuerCol) {
                const recordDateCol = headers.find(h => 
                    h.toLowerCase().includes('recorddate') || 
                    h.toLowerCase().includes('record_date') || 
                    h.toLowerCase().includes('record date') ||
                    h.toLowerCase().includes('meetingdate') ||
                    h.toLowerCase().includes('meeting_date')
                );
                const forRatioCol = headers.find(h => 
                    h.toLowerCase().includes('forratio') && h.toLowerCase().includes('true')
                );
                
                const peerRows = csvData.filter(row => (row[issuerCol] || '') === selectedIssuer);
                
                if (recordDateCol) {
                    const peerDates = peerRows.map(row => row[recordDateCol]).filter(Boolean);
                    allRecordDates.push(...peerDates);
                }
                
                if (forRatioCol) {
                    const peerRates = peerRows.map(row => parseFloat(row[forRatioCol])).filter(rate => !isNaN(rate));
                    peerApprovalRates.push(...peerRates);
                }
            }
            
            // Check large dataset for all data (record dates, services, mgmt recommendations, approved rates)
            if (largeCsvData.length > 0 && largeIssuerCol) {
                const recordDateCol = largeHeaders.find(h => 
                    h.toLowerCase().includes('recorddate') || 
                    h.toLowerCase().includes('record_date') || 
                    h.toLowerCase().includes('record date') ||
                    h.toLowerCase().includes('meetingdate') ||
                    h.toLowerCase().includes('meeting_date')
                );
                const serviceCol = largeHeaders.find(h => 
                    h.toLowerCase().includes('service') || 
                    h.toLowerCase().includes('services')
                );
                const mgmtRecCol = largeHeaders.find(h => 
                    h.toLowerCase().includes('mgmt_rec') || 
                    h.toLowerCase().includes('mgmtrec') ||
                    h.toLowerCase().includes('management_recommendation') ||
                    h.toLowerCase().includes('mgmt rec')
                );
                const forRatioCol = largeHeaders.find(h => 
                    h.toLowerCase().includes('forratio') && h.toLowerCase().includes('true')
                );
                
                const largeRows = largeCsvData.filter(row => (row[largeIssuerCol] || '') === selectedIssuer);
                
                if (recordDateCol) {
                    const largeDates = largeRows.map(row => row[recordDateCol]).filter(Boolean);
                    allRecordDates.push(...largeDates);
                }
                
                // Only aggregate services and mgmt recommendations from large dataset (no double counting)
                if (serviceCol) {
                    const largeServices = largeRows.map(row => row[serviceCol]).filter(Boolean);
                    allServices.push(...largeServices);
                }
                
                if (mgmtRecCol) {
                    const largeMgmtRecs = largeRows.map(row => row[mgmtRecCol]).filter(Boolean);
                    allMgmtRecs.push(...largeMgmtRecs);
                }
                
                if (forRatioCol) {
                    const largeRates = largeRows.map(row => parseFloat(row[forRatioCol]))
                        .filter(rate => !isNaN(rate) && rate >= 0.5); // Only approved proposals (>= 0.5)
                    largeApprovedRates.push(...largeRates);
                }
            }
            
            // Normalize dates to consistent format and remove duplicates
            const normalizedDates = [...new Set(allRecordDates.map(date => {
                // Helper to parse DD/MM/YYYY or DD-MM-YYYY as day first
                function parseDayFirst(d) {
                    if (typeof d !== 'string') return null;
                    let m = d.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/);
                    if (m) {
                        // DD/MM/YYYY or DD-MM-YYYY
                        const day = parseInt(m[1], 10);
                        const month = parseInt(m[2], 10);
                        const year = parseInt(m[3], 10);
                        // JS months are 0-based
                        return new Date(year, month - 1, day);
                    }
                    // Try YYYY-MM-DD
                    m = d.match(/^(\d{4})[\/\-](\d{1,2})[\/\-](\d{1,2})$/);
                    if (m) {
                        return new Date(parseInt(m[1], 10), parseInt(m[2], 10) - 1, parseInt(m[3], 10));
                    }
                    // Try Date constructor fallback
                    const dt = new Date(d);
                    if (!isNaN(dt.getTime())) return dt;
                    return null;
                }
                const parsedDate = parseDayFirst(date);
                if (parsedDate && !isNaN(parsedDate.getTime())) {
                    // Exclude future dates after 2025-06-01
                    const cutoff = new Date(2025, 5, 1); // June is month 5 (0-based)
                    if (parsedDate > cutoff) return null;
                    return parsedDate.toISOString().split('T')[0];
                }
                return null;
            }).filter(Boolean))];
            
            // Sort dates from past to present
            normalizedDates.sort((a, b) => {
                const dateA = new Date(a);
                const dateB = new Date(b);
                return dateA - dateB;
            });
            
            // Process services - count occurrences of each service type (from large dataset only)
            const serviceCounts = {};
            allServices.forEach(service => {
                const cleanService = service.trim();
                if (cleanService) {
                    serviceCounts[cleanService] = (serviceCounts[cleanService] || 0) + 1;
                }
            });
            
            // Process MGMT_REC - count occurrences of each recommendation type (from large dataset only)
            const mgmtRecCounts = {};
            allMgmtRecs.forEach(mgmtRec => {
                const cleanMgmtRec = mgmtRec.trim();
                if (cleanMgmtRec) {
                    mgmtRecCounts[cleanMgmtRec] = (mgmtRecCounts[cleanMgmtRec] || 0) + 1;
                }
            });
            
            // Create service summary string
            let serviceSummary = '';
            if (Object.keys(serviceCounts).length > 0) {
                const serviceEntries = Object.entries(serviceCounts)
                    .sort((a, b) => b[1] - a[1]) // Sort by count descending
                    .map(([service, count]) => count > 1 ? `${service} (${count})` : service);
                serviceSummary = serviceEntries.join(', ');
            }
            
            // Create MGMT_REC summary string
            let mgmtRecSummary = '';
            if (Object.keys(mgmtRecCounts).length > 0) {
                const mgmtRecEntries = Object.entries(mgmtRecCounts)
                    .sort((a, b) => b[1] - a[1]) // Sort by count descending
                    .map(([mgmtRec, count]) => count > 1 ? `${mgmtRec} (${count})` : mgmtRec);
                mgmtRecSummary = mgmtRecEntries.join(', ');
            }
            
            // Process peer approval rates
            let approvalRateSummary = '';
            if (peerApprovalRates.length > 0) {
                const minRate = Math.min(...peerApprovalRates);
                const maxRate = Math.max(...peerApprovalRates);
                approvalRateSummary = `${(minRate * 100).toFixed(1)}%-${(maxRate * 100).toFixed(1)}%`;
            }
            
            // Process large dataset approved rates
            let approvedRateSummary = '';
            if (largeApprovedRates.length > 0) {
                const minApprovedRate = Math.min(...largeApprovedRates);
                const maxApprovedRate = Math.max(...largeApprovedRates);
                approvedRateSummary = `${(minApprovedRate * 100).toFixed(1)}%-${(maxApprovedRate * 100).toFixed(1)}%`;
            }
            
            // Build summary text
            let summaryText = selectedIssuer || 'No issuer selected';
            
            if (normalizedDates.length > 0) {
                summaryText += '\n\nRecord Date(s): ' + normalizedDates.join(', ');
            } else {
                summaryText += '\n\nNo record dates found for this issuer.';
            }
            
            if (serviceSummary) {
                summaryText += '\n\nService(s): ' + serviceSummary;
            } else {
                summaryText += '\n\nNo services found for this issuer.';
            }
            
            if (mgmtRecSummary) {
                summaryText += '\n\nMgmt Recommendation(s): ' + mgmtRecSummary;
            } else {
                summaryText += '\n\nNo management recommendations found for this issuer.';
            }
            
            if (approvalRateSummary && approvedRateSummary) {
                summaryText += '\n\nFailed proposals shares approval rate: ' + approvalRateSummary + ', Approved proposals shares approval rate: ' + approvedRateSummary;
            } else if (approvalRateSummary) {
                summaryText += '\n\nFailed proposals shares approval rate: ' + approvalRateSummary;
            } else if (approvedRateSummary) {
                summaryText += '\n\nApproved proposals shares approval rate: ' + approvedRateSummary;
            } else {
                summaryText += '\n\nNo approval rates found for this issuer.';
            }
            
            // Add reject and approved proposal counts from large dataset
            let rejectedCount = 0;
            let approvedCount = 0;
            
            if (largeCsvData.length > 0 && largeIssuerCol && selectedIssuer) {
                const forRatioCol = largeHeaders.find(h => 
                    h.toLowerCase().includes('forratio') && h.toLowerCase().includes('true')
                );
                
                if (forRatioCol) {
                    const largeRows = largeCsvData.filter(row => (row[largeIssuerCol] || '') === selectedIssuer);
                    
                    largeRows.forEach(row => {
                        const forRatio = parseFloat(row[forRatioCol]);
                        if (!isNaN(forRatio)) {
                            if (forRatio < 0.5) {
                                rejectedCount++;
                            } else {
                                approvedCount++;
                            }
                        }
                    });
                }
            }
            
            summaryText += `\n\nReject proposal count: ${rejectedCount}     Approved proposal count: ${approvedCount}`;
            
            // Add detailed breakdown of rejected proposals
            if (rejectedCount > 0 && largeCsvData.length > 0 && largeIssuerCol && selectedIssuer) {
                const forRatioCol = largeHeaders.find(h => 
                    h.toLowerCase().includes('forratio') && h.toLowerCase().includes('true')
                );
                
                if (forRatioCol) {
                    // Get rejected proposals from large dataset for category aggregation
                    const rejectedProposalsLarge = largeCsvData.filter(row => {
                        const issuerMatch = (row[largeIssuerCol] || '') === selectedIssuer;
                        const forRatio = parseFloat(row[forRatioCol]);
                        return issuerMatch && !isNaN(forRatio) && forRatio < 0.5;
                    });
                    
                    if (rejectedProposalsLarge.length > 0) {
                        summaryText += '\n\nRejected Proposals Breakdown:';
                        
                        // Category-subcategory aggregation from large dataset
                        // Use CATEGORY_ANNOTATED and SUBCATEGORY_ANNOTATED from Peer Analysis dataset (headers)
                        const categoryAnnotatedCol = headers.find(h => h.trim().toLowerCase() === 'category_annotated');
                        const subcategoryAnnotatedCol = headers.find(h => h.trim().toLowerCase() === 'subcategory_annotated');
                        const categoryAggregation = {};
                        // Use peerProposals from Peer Analysis dataset for breakdown
                        const peerProposals = csvData.filter(row => (row[issuerCol] || '') === selectedIssuer);
                        peerProposals.forEach(row => {
                            const category = categoryAnnotatedCol ? (row[categoryAnnotatedCol] || 'Unknown') : 'Unknown';
                            const subcategory = subcategoryAnnotatedCol ? (row[subcategoryAnnotatedCol] || 'Unknown') : 'N/A';
                            const key = subcategoryAnnotatedCol ? `${category} | ${subcategory}` : category;
                            categoryAggregation[key] = (categoryAggregation[key] || 0) + 1;
                        });
                        
                        // First bullet: category summary with counts
                        const categoryEntries = Object.entries(categoryAggregation)
                            .sort((a, b) => b[1] - a[1])
                            .map(([key, count]) => `${key} (${count})`);
                        summaryText += '\nâ€¢ Category Summary: ' + categoryEntries.join(', ');
                        
                        // Only map to the "PROPOSAL" column (case-insensitive, exact match)
                        const proposalCol = headers.find(h => h.trim().toLowerCase() === 'proposal');
                        // If you need the proposal master key, use a separate variable:
                        const proposalMasterKeyCol = headers.find(h => h.trim().toLowerCase() === 'proposal_master_key');
                        
                        // Get individual proposal texts from peer analysis dataset
                        console.log('proposalCol resolved to:', proposalCol);
                        console.log('headers:', headers);
                        // Show a sample of the first 5 values for this column:
                        if (proposalCol && csvData.length > 0) {
                            console.log('Sample values for proposalCol:');
                            for (let i = 0; i < Math.min(5, csvData.length); i++) {
                                console.log(`Row ${i}:`, csvData[i][proposalCol]);
                            }
                        }
                        
                        if (proposalCol && csvData.length > 0 && issuerCol) {
                            const peerProposals = csvData.filter(row => (row[issuerCol] || '') === selectedIssuer);
                            peerProposals.forEach((row) => {
                                // Always use the proposal text from the PROPOSAL column
                                let proposalText = row[proposalCol];
                                if (proposalText && typeof proposalText === 'string') {
                                    proposalText = proposalText.trim();
                                }
                                if (proposalText && proposalText.length > 0) {
                                    // Truncate very long proposals for readability
                                    const truncatedText = proposalText.length > 200 ? 
                                        proposalText.substring(0, 200) + '...' : proposalText;
                                    summaryText += `\nâ€¢ ${truncatedText}`;
                                } else {
                                    summaryText += `\nâ€¢ No proposal text available`;
                                }
                            });
                        } else {
                            summaryText += '\nâ€¢ Proposal text column not found in peer analysis dataset';
                        }
                    }
                }
            }
            
            // --- Approved Proposals Breakdown ---
            // Find approved proposals in large dataset (ForRatioAmongVoted_true >= 0.5)
            const forRatioColLarge = largeHeaders.find(h => h.toLowerCase().includes('forratio') && h.toLowerCase().includes('true'));
            const categoryColLarge = largeHeaders.find(h => h.trim().toLowerCase() === 'category');
            const subcategoryColLarge = largeHeaders.find(h => h.trim().toLowerCase() === 'subcategory');
            const proposalColLarge = largeHeaders.find(h => h.trim().toLowerCase() === 'proposal');

            if (forRatioColLarge && categoryColLarge && selectedIssuer) {
                const approvedProposalsLarge = largeCsvData.filter(row => {
                    const issuerMatch = (row[largeIssuerCol] || '') === selectedIssuer;
                    const forRatio = parseFloat(row[forRatioColLarge]);
                    return issuerMatch && !isNaN(forRatio) && forRatio >= 0.5;
                });

                if (approvedProposalsLarge.length > 0) {
                    summaryText += '\n\nApproved Proposals Breakdown:';

                    // 1st bullet: aggregated counts of category|subcategory
                    const approvedCategoryAgg = {};
                    approvedProposalsLarge.forEach(row => {
                        const category = row[categoryColLarge] || 'Unknown';
                        const subcategory = subcategoryColLarge ? (row[subcategoryColLarge] || 'Unknown') : 'N/A';
                        const key = subcategoryColLarge ? `${category} | ${subcategory}` : category;
                        approvedCategoryAgg[key] = (approvedCategoryAgg[key] || 0) + 1;
                    });
                    const approvedCategoryEntries = Object.entries(approvedCategoryAgg)
                        .sort((a, b) => b[1] - a[1])
                        .map(([key, count]) => `${key} (${count})`);
                    summaryText += '\nâ€¢ Category Summary: ' + approvedCategoryEntries.join(', ');

                    // 2nd and subsequent bullets: enumerate proposal text
                    approvedProposalsLarge.forEach(row => {
                        let proposalText = proposalColLarge ? row[proposalColLarge] : '';
                        if (proposalText && typeof proposalText === 'string') {
                            proposalText = proposalText.trim();
                        }
                        if (proposalText && proposalText.length > 0) {
                            const truncatedText = proposalText.length > 200 ?
                                proposalText.substring(0, 200) + '...' : proposalText;
                            summaryText += `\nâ€¢ ${truncatedText}`;
                        } else {
                            summaryText += `\nâ€¢ No proposal text available`;
                        }
                    });
                }
            }
            
            // --- formatting for HTML output with bullets and line breaks ---
            // Convert summaryText to HTML: bullets as <ul><li>, line breaks as <br>
            function summaryTextToHtml(text) {
                // Split into sections by double line breaks
                const sections = text.split(/\n\n/);
                let html = '';
                for (let section of sections) {
                    // If section contains bullets
                    if (section.includes('\nâ€¢')) {
                        // Split into title and bullets
                        const [title, ...bullets] = section.split('\nâ€¢');
                        html += `<div>${escapeHtml(title.trim())}</div>`;
                        html += '<ul style="margin-top:4px; margin-bottom:10px; padding-left:22px;">';
                        for (let bullet of bullets) {
                            html += `<li style="margin-bottom:2px;">${escapeHtml(bullet.trim())}</li>`;
                        }
                        html += '</ul>';
                    } else {
                        // Just normal section, replace single \n with <br>
                        html += `<div style="margin-bottom:8px;">${escapeHtml(section.trim()).replace(/\n/g, '<br>')}</div>`;
                    }
                }
                return html;
            }

            summaryBox.innerHTML = summaryTextToHtml(summaryText);
            summaryBox.style.display = 'block';
        });

        // Enable/disable Show Summary button based on data availability and issuer selection
        function updateShowSummaryButton() {
            const btn = document.getElementById('showSummaryBtn');
            const peerDropdown = document.getElementById('issuerDropdownPeer');
            const largeDropdown = document.getElementById('issuerDropdownLarge');
            
            // Check if both datasets are loaded
            if (largeCsvData.length === 0 || csvData.length === 0) {
                btn.disabled = true;
                document.getElementById('summaryBox').style.display = 'none';
                return;
            }
            
            // Check if both dropdowns have the same issuer selected (and not empty)
            const peerValue = peerDropdown ? peerDropdown.value : '';
            const largeValue = largeDropdown ? largeDropdown.value : '';
            
            if (peerValue && largeValue && peerValue === largeValue && peerValue !== 'NONE') {
                btn.disabled = false;
            } else {
                btn.disabled = true;
                document.getElementById('summaryBox').style.display = 'none';
            }
        }

        // Wrap handleIssuerSelection to update summary button
        const original_handleIssuerSelection = handleIssuerSelection;
        handleIssuerSelection = function(selectedIssuer) {
            original_handleIssuerSelection.apply(this, arguments);
            updateShowSummaryButton();
        };

        // Wrap showAllRows to update summary button
        const original_showAllRows2 = showAllRows;
        showAllRows = function() {
            original_showAllRows2.apply(this, arguments);
            updateShowSummaryButton();
        };

        function generateCategoryChart() {
            // Use CATEGORY_ANNOTATED and SUBCATEGORY_ANNOTATED if present, else fallback
            categoryCol = headers.find(h => h.toLowerCase() === 'category_annotated') ||
                          headers.find(h => h.toLowerCase().includes('category') && !h.toLowerCase().includes('sub')) ||
                          null;
            subcategoryCol = headers.find(h => h.toLowerCase() === 'subcategory_annotated') ||
                             headers.find(h => h.toLowerCase().includes('subcategory') || h.toLowerCase().includes('sub')) ||
                             null;
            if (!categoryCol) {
                document.getElementById('chartContainer').innerHTML = '<div class="no-chart">No category column found in the data</div>';
                return;
            }

            // Aggregate data by [category, subcategory] from the appropriate dataset
            const dataToAggregate = (window.selectedIssuerKey && !window.selectedCategoryKey) ? 
                csvData.filter(row => {
                    const rowIssuer = row[issuerCol] || 'Unknown';
                    return rowIssuer === window.selectedIssuerKey;
                }) : csvData;
            
            const aggregation = {};
            dataToAggregate.forEach(row => {
                const category = row[categoryCol] || 'Unknown';
                const subcategory = subcategoryCol ? (row[subcategoryCol] || 'Unknown') : 'N/A';
                const key = subcategoryCol ? `${category} | ${subcategory}` : category;
                aggregation[key] = (aggregation[key] || 0) + 1;
            });

            // Filter out bars with count 0
            const filteredData = Object.entries(aggregation)
                .filter(item => item[1] > 0);

            // Sort by count (descending) and get top 30
            const sortedData = filteredData
                .sort((a, b) => b[1] - a[1])
                .slice(0, 30);

            if (sortedData.length === 0) {
                document.getElementById('chartContainer').innerHTML = '<div class="no-chart">No valid category data found</div>';
                return;
            }

            // Prepare chart data
            const labels = sortedData.map(item => item[0]);
            const counts = sortedData.map(item => item[1]);

            // Generate colors with proper index mapping
            let highlightIndex = -1;
            if (window.selectedCategoryKey) {
                highlightIndex = labels.findIndex(label => label === window.selectedCategoryKey);
            }
            const colors = generateColors(labels.length, highlightIndex);                // Clear previous chart
                categoryChart = safeDestroyChart(categoryChart);

            // Create canvas element
            document.getElementById('chartContainer').innerHTML = '<canvas id="categoryChartCanvas"></canvas>';
            const ctx = document.getElementById('categoryChartCanvas').getContext('2d');

            // Create horizontal bar chart
            categoryChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Count',
                        data: counts,
                        backgroundColor: colors.background,
                        borderColor: colors.border,
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `Count: ${context.parsed.x}`;
                                }
                            }
                        },
                        datalabels: {
                            anchor: 'center',
                            align: 'center',
                            color: '#222',
                            font: { weight: 'bold', size: 14 },
                            formatter: function(value) {
                                // Only show label if value > 0
                                return value > 0 ? value : '';
                            }
                        }
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            ticks: { precision: 0 },
                            title: { display: true, text: 'Count' }
                        },
                        y: {
                            ticks: {
                                // Ensure all 30 labels are shown, one per bar
                                autoSkip: false,
                                font: { size: 10 },
                                callback: function(value, index) {
                                    // Show the full label for each bar
                                    return labels[index];
                                },
                                maxTicksLimit: 30
                            }
                        }
                    },
                    layout: { padding: { left: 10, right: 10, top: 10, bottom: 10 } },
                    onClick: (event, elements) => {
                        try {
                            handleChartClick(event, elements, labels, 'category');
                        } catch (error) {
                            console.error('Error in category chart click handler:', error);
                        }
                    }
                },
                plugins: [ChartDataLabels]
            });
        }

        function generateIssuerChart() {
            // Find issuer column (case-insensitive)
            issuerCol = headers.find(h => h.toLowerCase().includes('issuer') || h.toLowerCase().includes('company') || h.toLowerCase().includes('firm')) || null;
            
            if (!issuerCol) {
                document.getElementById('issuerChartContainer').innerHTML = '<div class="no-chart">No issuer column found in the data</div>';
                return;
            }

            // Aggregate data by issuer from the appropriate dataset
            const dataToAggregate = (window.selectedCategoryKey && !window.selectedIssuerKey) ? 
                csvData.filter(row => {
                    const rowCategory = row[categoryCol] || 'Unknown';
                    const rowSubcategory = subcategoryCol ? (row[subcategoryCol] || 'Unknown') : null;
                    
                    if (subcategoryCol && window.selectedCategoryKey.includes(' | ')) {
                        const parts = window.selectedCategoryKey.split(' | ');
                        const targetCategory = parts[0];
                        const targetSubcategory = parts[1];
                        return rowCategory === targetCategory && rowSubcategory === targetSubcategory;
                    } else {
                        return rowCategory === window.selectedCategoryKey;
                    }
                }) : csvData;
            
            const aggregation = {};
            dataToAggregate.forEach(row => {
                const issuer = row[issuerCol] || 'Unknown';
                aggregation[issuer] = (aggregation[issuer] || 0) + 1;
            });

            // Filter out bars with count 0
            const filteredData = Object.entries(aggregation)
                .filter(item => item[1] > 0);

            // Sort by count (descending) and get top 30
            const sortedData = filteredData
                .sort((a, b) => b[1] - a[1])
                .slice(0, 30);

            if (sortedData.length === 0) {
                document.getElementById('issuerChartContainer').innerHTML = '<div class="no-chart">No valid issuer data found</div>';
                return;
            }

            // Prepare chart data
            const labels = sortedData.map(item => item[0]);
            const counts = sortedData.map(item => item[1]);

            // Generate colors with proper index mapping
            let highlightIndex = -1;
            if (window.selectedIssuerKey) {
                highlightIndex = labels.findIndex(label => label === window.selectedIssuerKey);
            }
            const colors = generateColors(labels.length, highlightIndex);

            // Clear previous chart
            issuerChart = safeDestroyChart(issuerChart);

            // Create canvas element
            document.getElementById('issuerChartContainer').innerHTML = '<canvas id="issuerChartCanvas"></canvas>';
            const ctx = document.getElementById('issuerChartCanvas').getContext('2d');

            // Create horizontal bar chart
            issuerChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Count',
                        data: counts,
                        backgroundColor: colors.background,
                        borderColor: colors.border,
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `Count: ${context.parsed.x}`;
                                }
                            }
                        },
                        datalabels: {
                            anchor: 'center',
                            align: 'center',
                            color: '#222',
                            font: { weight: 'bold', size: 14 },
                            formatter: function(value) {
                                // Only show label if value > 0
                                return value > 0 ? value : '';
                            }
                        }
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            ticks: { precision: 0 },
                            title: { display: true, text: 'Count' }
                        },
                        y: {
                            ticks: {
                                maxTicksLimit: 30,
                                font: { size: 10 }
                            }
                        }
                    },
                    layout: { padding: { left: 10, right: 10, top: 10, bottom: 10 } },
                    onClick: (event, elements) => {
                        try {
                            handleChartClick(event, elements, labels, 'issuer');
                        } catch (error) {
                            console.error('Error in issuer chart click handler:', error);
                        }
                    }
                },
                plugins: [ChartDataLabels]
            });
        }

        // Sorting state for comparison chart
        let comparisonSortMode = 'rejected'; // default: sort by rejected count

        function updateSortButtonStates() {
            document.getElementById('sortByTotalBtn').disabled = (comparisonSortMode === 'total');
            document.getElementById('sortByRejectedBtn').disabled = (comparisonSortMode === 'rejected');
            document.getElementById('sortByRejectedPctBtn').disabled = (comparisonSortMode === 'rejectedPct');
        }

        document.getElementById('sortByTotalBtn').addEventListener('click', function() {
            comparisonSortMode = 'total';
            updateSortButtonStates();
            generateComparisonChart();
        });
        document.getElementById('sortByRejectedBtn').addEventListener('click', function() {
            comparisonSortMode = 'rejected';
            updateSortButtonStates();
            generateComparisonChart();
        });
        document.getElementById('sortByRejectedPctBtn').addEventListener('click', function() {
            comparisonSortMode = 'rejectedPct';
            updateSortButtonStates();
            generateComparisonChart();
        });

        // Ensure correct button state on initial load and after chart generation
        updateSortButtonStates();

        // Store last shown issuer labels for export
        let lastComparisonChartLabels = [];

        function generateComparisonChart() {
            // Only generate if both datasets are loaded
            if (!csvData.length || !largeCsvData.length || !issuerCol || !largeIssuerCol) {
                document.getElementById('comparisonChartContainer').innerHTML = '<div class="no-chart">Upload both datasets to see issuer proposal comparison</div>';
                // Reset title
                document.getElementById('comparisonChartTitle').textContent = 'Issuer Proposal Comparison';
                return;
            }

            // Update title based on category filter
            let titleText = 'Issuer Proposal Comparison';
            if (window.selectedCategoryKey) {
                titleText += ` - ${window.selectedCategoryKey}`;
            }
            document.getElementById('comparisonChartTitle').textContent = titleText;

            // Determine which data to aggregate based on current filters
            let smallDataToAggregate = csvData;
            let largeDataToAggregate = largeCsvData;
            
            // Apply category filtering if selected
            if (window.selectedCategoryKey) {
                smallDataToAggregate = csvData.filter(row => {
                    const rowCategory = row[categoryCol] || 'Unknown';
                    const rowSubcategory = subcategoryCol ? (row[subcategoryCol] || 'Unknown') : null;
                    
                    if (subcategoryCol && window.selectedCategoryKey.includes(' | ')) {
                        const parts = window.selectedCategoryKey.split(' | ');
                        const targetCategory = parts[0];
                        const targetSubcategory = parts[1];
                        return rowCategory === targetCategory && rowSubcategory === targetSubcategory;
                    } else {
                        return rowCategory === window.selectedCategoryKey;
                    }
                });
                
                largeDataToAggregate = largeCsvData.filter(row => {
                    const rowCategory = row[largeCategoryCol] || 'Unknown';
                    const rowSubcategory = largeSubcategoryCol ? (row[largeSubcategoryCol] || 'Unknown') : null;
                    
                    if (largeSubcategoryCol && window.selectedCategoryKey.includes(' | ')) {
                        const parts = window.selectedCategoryKey.split(' | ');
                        const targetCategory = parts[0];
                        const targetSubcategory = parts[1];
                        return rowCategory === targetCategory && rowSubcategory === targetSubcategory;
                    } else {
                        return rowCategory === window.selectedCategoryKey;
                    }
                });
            }
            
            // Apply issuer filtering if selected (hide all other issuers)
            if (window.selectedIssuerKey) {
                smallDataToAggregate = smallDataToAggregate.filter(row => {
                    const rowIssuer = row[issuerCol] || 'Unknown';
                    return rowIssuer === window.selectedIssuerKey;
                });
                
                largeDataToAggregate = largeDataToAggregate.filter(row => {
                    const rowIssuer = row[largeIssuerCol] || 'Unknown';
                    return rowIssuer === window.selectedIssuerKey;
                });
            }

            // Apply management proposal filter if checkbox is checked
            const mgmtFilterCheckbox = document.getElementById('mgmtProposalFilter');
            if (mgmtFilterCheckbox && mgmtFilterCheckbox.checked) {
                // Find proposal_type column in large dataset
                const proposalTypeColumn = Object.keys(largeCsvData[0] || {}).find(col => 
                    col.toLowerCase().includes('proposal_type') || col.toLowerCase().includes('proposaltype')
                );
                
                if (proposalTypeColumn) {
                    largeDataToAggregate = largeDataToAggregate.filter(row => {
                        const proposalType = row[proposalTypeColumn] || '';
                        return proposalType.trim().toUpperCase() === 'MG';
                    });
                }
            }

            // Find ForRatioAmongVoted_true column in large dataset
            const forRatioColumn = Object.keys(largeCsvData[0] || {}).find(col => 
                col.toLowerCase().includes('forratio') && col.toLowerCase().includes('true')
            );
            
            if (!forRatioColumn) {
                document.getElementById('comparisonChartContainer').innerHTML = '<div class="no-chart">ForRatioAmongVoted_true column not found in large dataset</div>';
                return;
            }

            // Aggregate large dataset by issuer using ForRatioAmongVoted_true threshold
            const rejectedAggregation = {};
            const approvedAggregation = {};
            
            largeDataToAggregate.forEach(row => {
                const issuer = row[largeIssuerCol] || 'Unknown';
                const forRatio = parseFloat(row[forRatioColumn]);
                
                if (!isNaN(forRatio)) {
                    if (forRatio < 0.5) {
                        // Rejected: ForRatioAmongVoted_true < 0.5
                        rejectedAggregation[issuer] = (rejectedAggregation[issuer] || 0) + 1;
                    } else {
                        // Approved: ForRatioAmongVoted_true >= 0.5
                        approvedAggregation[issuer] = (approvedAggregation[issuer] || 0) + 1;
                    }
                }
            });

            // Also aggregate small dataset (contains only rejected proposals) for reference
            const smallRejectedAggregation = {};
            smallDataToAggregate.forEach(row => {
                const issuer = row[issuerCol] || 'Unknown';
                smallRejectedAggregation[issuer] = (smallRejectedAggregation[issuer] || 0) + 1;
            });

            // Combine and prepare data for stacked bars
            const combinedData = {};
            
            // Add all issuers from both aggregations
            [...Object.keys(rejectedAggregation), ...Object.keys(approvedAggregation), ...Object.keys(smallRejectedAggregation)].forEach(issuer => {
                if (!combinedData[issuer]) {
                    combinedData[issuer] = {
                        rejected: rejectedAggregation[issuer] || 0,
                        approved: approvedAggregation[issuer] || 0,
                        smallRejected: smallRejectedAggregation[issuer] || 0
                    };
                }
            });

            // Remove issuers where both rejected and approved are 0
            const filteredCombinedData = Object.entries(combinedData)
                .filter(([issuer, data]) => (data.rejected > 0 || data.approved > 0))
                .reduce((obj, [issuer, data]) => { obj[issuer] = data; return obj; }, {});

            // Sorting logic based on comparisonSortMode
            let sortedIssuers;
            if (comparisonSortMode === 'total') {
                sortedIssuers = Object.entries(filteredCombinedData)
                    .sort((a, b) => ((b[1].rejected + b[1].approved) - (a[1].rejected + a[1].approved)))
                    .slice(0, 30);
            } else if (comparisonSortMode === 'rejectedPct') {
                sortedIssuers = Object.entries(filteredCombinedData)
                    .sort((a, b) => {
                        const aTotal = a[1].rejected + a[1].approved;
                        const bTotal = b[1].rejected + b[1].approved;
                        const aPct = aTotal > 0 ? a[1].rejected / aTotal : 0;
                        const bPct = bTotal > 0 ? b[1].rejected / bTotal : 0;
                        // Primary: rejected percentage, Secondary: rejected count
                        if (bPct !== aPct) {
                            return bPct - aPct;
                        } else {
                            return b[1].rejected - a[1].rejected;
                        }
                    })
                    .slice(0, 30);
            } else { // default: rejected
                sortedIssuers = Object.entries(filteredCombinedData)
                    .sort((a, b) => b[1].rejected - a[1].rejected)
                    .slice(0, 30);
            }

            if (sortedIssuers.length === 0) {
                document.getElementById('comparisonChartContainer').innerHTML = '<div class="no-chart">No valid issuer data found for comparison</div>';
                return;
            }

            // Prepare chart data
            const labels = sortedIssuers.map(item => item[0]);
            lastComparisonChartLabels = labels; // Save for export
            const rejectedCounts = sortedIssuers.map(item => item[1].rejected);
            const approvedCounts = sortedIssuers.map(item => item[1].approved);

            // Clear previous chart
            comparisonChart = safeDestroyChart(comparisonChart);

            // Create canvas element
            document.getElementById('comparisonChartContainer').innerHTML = '<canvas id="comparisonChartCanvas"></canvas>';
            const ctx = document.getElementById('comparisonChartCanvas').getContext('2d');

            // Create stacked horizontal bar chart
            comparisonChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Rejected (ForRatio < 0.5)',
                            data: rejectedCounts,
                            backgroundColor: '#e74c3c80',
                            borderColor: '#e74c3c',
                            borderWidth: 1,
                            datalabels: {
                                anchor: 'center',
                                align: 'center',
                                color: '#222',
                                font: { weight: 'bold', size: 14 },
                                formatter: function(value) {
                                    // Only show label if value > 0
                                    return value > 0 ? value : '';
                                }
                            }
                        },
                        {
                            label: 'Approved (ForRatio >= 0.5)',
                            data: approvedCounts,
                            backgroundColor: '#27ae6080',
                            borderColor: '#27ae60',
                            borderWidth: 1,
                            datalabels: {
                                anchor: 'center',
                                align: 'center',
                                color: '#222',
                                font: { weight: 'bold', size: 14 },
                                formatter: function(value) {
                                    // Only show label if value > 0
                                    return value > 0 ? value : '';
                                }
                            }
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    scales: {
                        x: {
                            stacked: true,
                            beginAtZero: true,
                            ticks: { precision: 0 },
                            title: { display: true, text: 'Count' }
                        },
                        y: {
                            stacked: true,
                            ticks: {
                                maxTicksLimit: 30,
                                autoSkip: false,
                                font: { size: 10 },
                                callback: function(value, index) {
                                    return labels[index];
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: { display: true, position: 'top' },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const issuer = context.label;
                                    const data = combinedData[issuer];
                                    if (context.datasetIndex === 0) {
                                        const smallRef = data.smallRejected > 0 ? ` (Small dataset: ${data.smallRejected})` : '';
                                        return `Rejected (ForRatio < 0.5): ${data.rejected}${smallRef}`;
                                    } else {
                                        return `Approved (ForRatio >= 0.5): ${data.approved}`;
                                    }
                                }
                            }
                        }
                        // No global datalabels config here; handled per dataset above
                    },
                    layout: { padding: { left: 10, right: 10, top: 10, bottom: 10 } },
                    onHover: (event, activeElements) => {
                        event.native.target.style.cursor = activeElements.length > 0 ? 'pointer' : 'default';
                    },
                    animation: {
                        onComplete: function(animation) {
                            try {
                                // Draw rejection percentages at the end of bars
                                const chart = animation.chart;
                                const ctx = chart.ctx;
                                const chartArea = chart.chartArea;
                                
                                if (!ctx || !chartArea) {
                                    console.warn('Chart context or chart area not available');
                                    return;
                                }
                                
                                ctx.save();
                                ctx.font = '10px Arial';
                                ctx.fillStyle = '#666';
                                ctx.textAlign = 'left';
                                ctx.textBaseline = 'middle';
                                
                                labels.forEach((label, index) => {
                                    try {
                                        const data = combinedData[label];
                                        if (!data) return;
                                        
                                        const totalProposals = data.rejected + data.approved;
                                        const rejectionPercentage = totalProposals > 0 ? ((data.rejected / totalProposals) * 100).toFixed(1) : '0.0';
                                        
                                        // Get the bar position
                                        const meta = chart.getDatasetMeta(0);
                                        const secondMeta = chart.getDatasetMeta(1);
                                        
                                        if (!meta || !secondMeta || !meta.data[index] || !secondMeta.data[index]) {
                                            return;
                                        }
                                        
                                        const bar = meta.data[index];
                                        const secondBar = secondMeta.data[index];
                                        
                                        // Calculate the end position of the stacked bar
                                        const totalWidth = Math.max(bar.x, secondBar.x);
                                        const yPosition = bar.y;
                                        
                                        // Draw percentage text at the end of the bar
                                        ctx.fillText(`${rejectionPercentage}%`, totalWidth + 5, yPosition);
                                    } catch (e) {
                                        console.warn('Error drawing percentage for label:', label, e);
                                    }
                                });
                                
                                ctx.restore();
                            } catch (error) {
                                console.error('Error in chart animation callback:', error);
                            }
                        }
                    }
                },
                plugins: [ChartDataLabels]
            });
        }

        function generateColors(count, highlightIndex = -1) {
            const background = [];
            const border = [];
            const darkBlue = '#2c3e50'; // Dark blue color
            const highlightColor = '#e74c3c'; // Red color for highlighting
            
            for (let i = 0; i < count; i++) {
                if (i === highlightIndex) {
                    background.push(highlightColor + '80'); // Add transparency to highlight color
                    border.push(highlightColor);
                } else {
                    background.push(darkBlue + '80'); // Add transparency
                    border.push(darkBlue);
                }
            }

            return { background, border };
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showFileInfo(filename, rowCount, columnCount) {
            const infoDiv = document.getElementById('fileInfo');
            infoDiv.innerHTML = `
                <div class="file-info">
                    <strong>File loaded successfully:</strong> ${escapeHtml(filename)}<br>
                    <strong>Rows:</strong> ${rowCount} | <strong>Columns:</strong> ${columnCount}
                </div>
            `;
        }

        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.innerHTML = `<div class="error-message"><strong>Error:</strong> ${escapeHtml(message)}</div>`;
        }

        function showFilterInfo(filterKey, filteredCount) {
            const filterDiv = document.getElementById('filterInfo');
            filterDiv.innerHTML = `
                <strong>Filtered by:</strong> ${escapeHtml(filterKey)}<br>
                <strong>Highlighted Rows:</strong> ${filteredCount} | <strong>Columns:</strong> ${headers.length}
            `;
            filterDiv.style.display = 'block';
        }

        function hideFilterInfo() {
            const filterDiv = document.getElementById('filterInfo');
            filterDiv.style.display = 'none';
        }

        function handleChartClick(event, elements, labels, chartType) {
            if (elements.length > 0) {
                // Bar was clicked - filter by the selected category/subcategory or issuer
                const clickedIndex = elements[0].index;
                const selectedKey = labels[clickedIndex];
                
                console.log('Chart clicked:', chartType, 'Key:', selectedKey);
                
                if (chartType === 'category') {
                    selectedCategoryIndex = clickedIndex;
                    filterTableByCombined(selectedKey, null);
                } else if (chartType === 'issuer') {
                    selectedIssuerIndex = clickedIndex;
                    filterTableByCombined(null, selectedKey);
                }
                
                // Use debounced regeneration to avoid race conditions
                regenerateChartsDebounced();
            } else {
                // Clicked outside any bar - show all data
                showAllRows();
            }
        }

        function filterTableByCombined(categoryKey, issuerKey) {
            // Store the selected keys globally for reference
            window.selectedCategoryKey = categoryKey || window.selectedCategoryKey;
            window.selectedIssuerKey = issuerKey || window.selectedIssuerKey;
            
            // Filter the data based on both criteria if available
            filteredData = csvData.filter(row => {
                let matchesCategory = true;
                let matchesIssuer = true;
                
                // Check category filter
                if (window.selectedCategoryKey) {
                    const rowCategory = row[categoryCol] || 'Unknown';
                    const rowSubcategory = subcategoryCol ? (row[subcategoryCol] || 'Unknown') : null;
                    
                    if (subcategoryCol && window.selectedCategoryKey.includes(' | ')) {
                        const parts = window.selectedCategoryKey.split(' | ');
                        const targetCategory = parts[0];
                        const targetSubcategory = parts[1];
                        matchesCategory = rowCategory === targetCategory && rowSubcategory === targetSubcategory;
                    } else {
                        matchesCategory = rowCategory === window.selectedCategoryKey;
                    }
                }
                
                // Check issuer filter
                if (window.selectedIssuerKey) {
                    const rowIssuer = row[issuerCol] || 'Unknown';
                    matchesIssuer = rowIssuer === window.selectedIssuerKey;
                }
                
                return matchesCategory && matchesIssuer;
            });

            // Re-render table with filtered data
            renderFilteredTable();
            
            // Apply same filters to large dataset if loaded
            if (largeCsvData.length > 0) {
                applyFiltersToLargeDataset();
            }
            
            // Update filter info
            let filterText = '';
            if (window.selectedCategoryKey && window.selectedIssuerKey) {
                filterText = `Category: ${window.selectedCategoryKey} & Issuer: ${window.selectedIssuerKey}`;
            } else if (window.selectedCategoryKey) {
                filterText = `Category: ${window.selectedCategoryKey}`;
            } else if (window.selectedIssuerKey) {
                filterText = `Issuer: ${window.selectedIssuerKey}`;
            }
            
            if (filterText) {
                showFilterInfo(filterText, filteredData.length);
                
                // Update chart titles
                const chartTitles = document.querySelectorAll('.chart-title');
                chartTitles[0].textContent = `Category Distribution - ${filterText}`;
                if (chartTitles[1]) {
                    chartTitles[1].textContent = `Issuer Distribution - ${filterText}`;
                }
            }
        }

        function filterTableByCategory(selectedKey) {
            // Parse the key to extract category and subcategory
            let targetCategory, targetSubcategory;
            
            if (subcategoryCol && selectedKey.includes(' | ')) {
                const parts = selectedKey.split(' | ');
                targetCategory = parts[0];
                targetSubcategory = parts[1];
            } else {
                targetCategory = selectedKey;
                targetSubcategory = null;
            }

            // Filter the data
            filteredData = csvData.filter(row => {
                const rowCategory = row[categoryCol] || 'Unknown';
                const rowSubcategory = subcategoryCol ? (row[subcategoryCol] || 'Unknown') : null;
                
                if (subcategoryCol && targetSubcategory) {
                    return rowCategory === targetCategory && rowSubcategory === targetSubcategory;
                } else {
                    return rowCategory === targetCategory;
                }
            });

            // Re-render table with filtered data
            renderFilteredTable();
            
            // Update filter info
            showFilterInfo(`Category: ${selectedKey}`, filteredData.length);
            
            // Update chart title to show filter
            document.querySelector('.chart-title').textContent = `Category Distribution - Filtered by: ${selectedKey}`;
        }

        function filterTableByIssuer(selectedKey) {
            // Filter the data by issuer
            filteredData = csvData.filter(row => {
                const rowIssuer = row[issuerCol] || 'Unknown';
                return rowIssuer === selectedKey;
            });

            // Re-render table with filtered data
            renderFilteredTable();
            
            // Update filter info
            showFilterInfo(`Issuer: ${selectedKey}`, filteredData.length);
            
            // Update chart title to show filter
            const chartTitles = document.querySelectorAll('.chart-title');
            chartTitles[1].textContent = `Issuer Distribution - Filtered by: ${selectedKey}`;
        }

        function showAllRows() {
            filteredData = [...csvData];
            selectedCategoryIndex = -1;
            selectedIssuerIndex = -1;
            window.selectedCategoryKey = null;
            window.selectedIssuerKey = null;
            renderFilteredTable();
            hideFilterInfo();
            
            // Also reset large dataset if loaded
            if (largeCsvData.length > 0) {
                largeFilteredData = [...largeCsvData];
                renderLargeFilteredTable();
            }
            
            const chartTitles = document.querySelectorAll('.chart-title');
                       chartTitles[0].textContent = 'Category Distribution';
            if (chartTitles[1]) {
                chartTitles[1].textContent = 'Issuer Distribution';
            }
            // Regenerate both charts to clear highlighting
            regenerateChartsDebounced();
        }

        function renderFilteredTable() {
            const container = document.getElementById('tableContainer');
            
            if (!filteredData.length || !headers.length) {
                container.innerHTML = '<div class="no-data">No data matches the selected filter.</div>';
                return;
            }

            let html = '<table><thead><tr>';
            
            // Create header row with special classes
            headers.forEach(function(header) {
                const lowerHeader = header.toLowerCase();
                let headerClass = '';
                
                if (lowerHeader.includes('proposal')) {
                    headerClass = 'proposal-header';
                } else if (lowerHeader.includes('category')) {
                    headerClass = 'category-header';
                } else if (lowerHeader.includes('issuer') || lowerHeader.includes('company')) {
                    headerClass = 'issuer-header';
                }
                
                html += `<th class="${headerClass}">${escapeHtml(header)}</th>`;
            });
            html += '</tr></thead><tbody>';

            // Create data rows from filtered data with appropriate styling
            filteredData.forEach((row, index) => {
                html += '<tr>';
                headers.forEach(function(header) {
                    const cellValue = row[header] || '';
                    const lowerHeader = header.toLowerCase();
                    let cellClass = '';
                    
                    if (lowerHeader.includes('proposal')) {
                        cellClass = 'proposal-cell';
                    } else if (lowerHeader.includes('category')) {
                        cellClass = 'category-cell';
                    } else if (lowerHeader.includes('issuer') || lowerHeader.includes('company')) {
                        cellClass = 'issuer-cell';
                    } else if (lowerHeader.includes('ratio') || lowerHeader.includes('percent') || 
                              lowerHeader.includes('count') || lowerHeader.includes('number') ||
                              !isNaN(parseFloat(cellValue))) {
                        cellClass = 'numeric-cell';
                    }
                    
                    html += `<td class="${cellClass}">${escapeHtml(cellValue)}</td>`;
                });
                html += '</tr>';
            });

            html += '</tbody></table>';
            container.innerHTML = html;
        }

        // Helper function to safely destroy charts
        function safeDestroyChart(chart) {
            if (chart && chart.destroy) {
                try {
                    chart.destroy();
                } catch (error) {
                    console.warn('Error destroying chart:', error);
                }
            }
            return null;
        }

        // Debounced chart regeneration to prevent race conditions
        function regenerateChartsDebounced() {
            if (chartRegenerationTimeout) {
                clearTimeout(chartRegenerationTimeout);
            }
            
            chartRegenerationTimeout = setTimeout(() => {
                try {
                    console.log('Regenerating charts...');
                    generateCategoryChart();
                    generateIssuerChart();
                    generateComparisonChart();
                    console.log('Charts regenerated successfully');
                } catch (error) {
                    console.error('Error regenerating charts:', error);
                }
            }, 150);
        }

        // Large dataset helper functions
        function showLargeFileInfo(filename, rowCount, columnCount) {
            const infoDiv = document.getElementById('largeFileInfo');
            infoDiv.innerHTML = `
                <div class="dataset-info">
                    <strong>Large dataset loaded:</strong> ${escapeHtml(filename)}<br>
                    <strong>Total Rows:</strong> ${rowCount} | <strong>Columns:</strong> ${columnCount}<br>
                    <strong>Displaying:</strong> Top 100 rows with synchronized filtering
                </div>
            `;
        }

        function showLargeError(message) {
            const errorDiv = document.getElementById('largeErrorMessage');
            errorDiv.innerHTML = `<div class="error-message"><strong>Error:</strong> ${escapeHtml(message)}</div>`;
        }

        function applyFiltersToLargeDataset() {
            if (!largeCsvData.length) return;
            
            largeFilteredData = largeCsvData.filter(row => {
                let matchesCategory = true;
                let matchesIssuer = true;
                
                // Check category filter
                if (window.selectedCategoryKey && largeCategoryCol) {
                    const rowCategory = row[largeCategoryCol] || 'Unknown';
                    const rowSubcategory = largeSubcategoryCol ? (row[largeSubcategoryCol] || 'Unknown') : null;
                    
                    if (largeSubcategoryCol && window.selectedCategoryKey.includes(' | ')) {
                        const parts = window.selectedCategoryKey.split(' | ');
                        const targetCategory = parts[0];
                        const targetSubcategory = parts[1];
                        matchesCategory = rowCategory === targetCategory && rowSubcategory === targetSubcategory;
                    } else {
                        matchesCategory = rowCategory === window.selectedCategoryKey;
                    }
                }
                
                // Check issuer filter
                if (window.selectedIssuerKey && largeIssuerCol) {
                    const rowIssuer = row[largeIssuerCol] || 'Unknown';
                    matchesIssuer = rowIssuer === window.selectedIssuerKey;
                }
                
                return matchesCategory && matchesIssuer;
            });

            renderLargeFilteredTable();
        }

        function renderLargeFilteredTable() {
            const container = document.getElementById('largeTableContainer');
            
            if (!largeFilteredData.length || !largeHeaders.length) {
                container.innerHTML = '<div class="no-data">No data matches the selected filter in the large dataset.</div>';
                return;
            }

            // Show only top 100 rows
            const displayData = largeFilteredData.slice(0,  100);
            
            let html = '<table><thead><tr>';
            
            // Create header row with special classes
            largeHeaders.forEach(header => {
                const lowerHeader = header.toLowerCase();
                               let headerClass = '';
                
                if (lowerHeader.includes('proposal')) {
                    headerClass = 'proposal-header';
                } else if (lowerHeader.includes('category')) {
                    headerClass = 'category-header';
                } else if (lowerHeader.includes('issuer') || lowerHeader.includes('company')) {
                    headerClass = 'issuer-header';
                }
                
                html += `<th class="${headerClass}">${escapeHtml(header)}</th>`;
            });
            html += '</tr></thead><tbody>';

            // Create data rows from filtered data with appropriate styling
            displayData.forEach((row, index) => {
                html += '<tr>';
                largeHeaders.forEach(header => {
                    const cellValue = row[header] || '';
                    const lowerHeader = header.toLowerCase();
                    let cellClass = '';
                    
                    if (lowerHeader.includes('proposal')) {
                        cellClass = 'proposal-cell';
                    } else if (lowerHeader.includes('category')) {
                        cellClass = 'category-cell';
                    } else if (lowerHeader.includes('issuer') || lowerHeader.includes('company')) {
                        cellClass = 'issuer-cell';
                    } else if (lowerHeader.includes('ratio') || lowerHeader.includes('percent') || 
                              lowerHeader.includes('count') || lowerHeader.includes('number') ||
                              !isNaN(parseFloat(cellValue))) {
                        cellClass = 'numeric-cell';
                    }
                    
                    html += `<td class="${cellClass}">${escapeHtml(cellValue)}</td>`;
                });
                html += '</tr>';
            });

            html += '</tbody></table>';
            
            // Add summary info
            if (largeFilteredData.length > 100) {
                html += `<div class="dataset-info" style="margin-top: 10px;">
                    Showing top 100 of ${largeFilteredData.length} filtered rows
                </div>`;
            }
            
            container.innerHTML = html;
        }

        // Default file loading functionality
        document.getElementById('loadDefaultBtn').addEventListener('click', function() {
            console.log('Load Default File button clicked');
            
            // Show loading state
            this.disabled = true;
            this.textContent = 'Loading...';
            
            loadDefaultFile('/default-peer-analysis', false)
                .then(() => {
                    console.log('Default file loaded successfully');
                })
                .catch((error) => {
                    console.error('Failed to load default file:', error);
                })
                .finally(() => {
                    this.disabled = false;
                    this.textContent = 'Load Default File';
                });
        });

        document.getElementById('loadDefaultLargeBtn').addEventListener('click', function() {
            console.log('Load Default Large File button clicked');
            
            // Show loading state
            this.disabled = true;
            this.textContent = 'Loading...';
            
            loadDefaultFile('/default-large-dataset', true)
                .then(() => {
                    console.log('Default large file loaded successfully');
                })
                .catch((error) => {
                    console.error('Failed to load default large file:', error);
                })
                .finally(() => {
                    this.disabled = false;
                    this.textContent = 'Load Default File';
                });
        });

        async function loadDefaultFile(endpoint, isLargeDataset) {
            console.log(`Loading default file from: ${endpoint}, isLargeDataset: ${isLargeDataset}`);
            
            return new Promise((resolve, reject) => {
                fetch(endpoint)
                    .then(response => {
                        console.log(`Response status: ${response.status}, OK: ${response.ok}`);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.text();
                    })
                    .then(csvText => {
                        console.log(`CSV text length: ${csvText.length}`);
                        console.log('First 200 chars:', csvText.substring(0, 200));
                        
                        // Use Papa Parse to parse the CSV text
                        Papa.parse(csvText, {
                            header: true,
                            skipEmptyLines: true,
                            complete: function(results) {
                                console.log('Papa Parse complete:', {
                                    dataLength: results.data.length,
                                    errors: results.errors,
                                    fields: results.meta.fields
                                });
                                
                                if (results.errors.length > 0) {
                                    console.error('Error parsing default CSV:', results.errors[0].message);
                                    if (isLargeDataset) {
                                        showLargeError('Error parsing default file: ' + results.errors[0].message);
                                    } else {
                                        showError('Error parsing default file: ' + results.errors[0].message);
                                    }
                                    reject(new Error('Papa Parse error: ' + results.errors[0].message));
                                    return;
                                }

                                const parsedData = results.data;
                                const filename = isLargeDataset ? 'Default Large Dataset' : 'Default Peer Analysis';
                                
                                console.log(`Loading ${filename} with ${parsedData.length} rows`);
                                
                                try {
                                    if (isLargeDataset) {
                                        loadLargeDatasetFromData(parsedData, filename);
                                    } else {
                                        loadDatasetFromData(parsedData, filename);
                                    }
                                    resolve();
                                } catch (error) {
                                    console.error('Error in load function:', error);
                                    reject(error);
                                }
                                                       },
                            error: function(error) {
                                console.error('Papa Parse error:', error);
                                if (isLargeDataset) {
                                    showLargeError('Error parsing default file: ' + error.message);
                                } else {
                                    showError('Error parsing default file: ' + error.message);
                                }
                                reject(error);
                            }
                        });
                    })
                    .catch(error => {
                        console.error('Error loading default file:', error);
                        if (isLargeDataset) {
                            showLargeError('Error loading default file: ' + error.message);
                        } else {
                            showError('Error loading default file: ' + error.message);
                        }
                        reject(error);
                    });
            });
        }

        function loadDatasetFromData(parsedData, filename) {
            if (parsedData.length === 0) {
                showError('Default file is empty or invalid');
               
                return;
            }
            
            // Update global variables
            csvData = parsedData;
            headers = Object.keys(parsedData[0]);
            
            // Clear previous data and messages
            document.getElementById('errorMessage').innerHTML = '';
            
            // Show file info
            showFileInfo(filename, csvData.length, headers.length);
            
            // Initialize filtered data
            filteredData = [...csvData];
            
            // Set columns for charts/filters
            categoryCol = headers.find(h => h.toLowerCase().includes('category') && !h.toLowerCase().includes('sub')) || null;
            subcategoryCol = headers.find(h => h.toLowerCase().includes('subcategory') || h.toLowerCase().includes('sub')) || null;
            issuerCol = headers.find(h => h.toLowerCase().includes('issuer') || h.toLowerCase().includes('company') || h.toLowerCase().includes('firm')) || null;
            
            // Render table and charts
            renderFilteredTable();
            generateCategoryChart();
            generateIssuerChart();
            generateComparisonChart();
            
            // Update button states
            document.getElementById('clearBtn').disabled = false;
            document.getElementById('showAllBtn').disabled = false;
            document.getElementById('showAllIssuerBtn').disabled = false;
        }

        function loadLargeDatasetFromData(parsedData, filename) {
            if (parsedData.length === 0) {
                showLargeError('Default large dataset file is empty or invalid');
                return;
            }
            
            // Update global variables
            largeCsvData = parsedData;
            largeHeaders = Object.keys(parsedData[0]);
            
            // Clear previous data and messages
            document.getElementById('largeErrorMessage').innerHTML = '';
            
            // Show file info
            showLargeFileInfo(filename, largeCsvData.length, largeHeaders.length);
            
            // Initialize filtered data
            largeFilteredData = [...largeCsvData];
            
            // Find columns for filtering
            largeCategoryCol = largeHeaders.find(h => h.toLowerCase().includes('category') && !h.toLowerCase().includes('sub')) || null;
            largeSubcategoryCol = largeHeaders.find(h => h.toLowerCase().includes('subcategory') || h.toLowerCase().includes('sub')) || null;
            largeIssuerCol = largeHeaders.find(h => h.toLowerCase().includes('issuer') || h.toLowerCase().includes('company') || h.toLowerCase().includes('firm')) || null;
            
            // Render table (top 100 rows)
            renderLargeFilteredTable();
            
            // Apply current filters if any exist
            if (window.selectedCategoryKey || window.selectedIssuerKey) {
                applyFiltersToLargeDataset();
            }
            
            // Generate comparison chart if rejected dataset is available
            generateComparisonChart();
            
            // Update button states
            document.getElementById('clearLargeBtn').disabled = false;
            updateShowSummaryButton();
        }

        // --- NON-INVASIVE ISSUER DROPDOWN INTEGRATION FOR BOTH DATASETS ---

        // Synchronization flag to avoid infinite loops
        let isSyncingDropdowns = false;

        // 1. Add event listeners to the dropdowns
        document.addEventListener('DOMContentLoaded', function() {
            const peerDropdown = document.getElementById('issuerDropdownPeer');
            const largeDropdown = document.getElementById('issuerDropdownLarge');
            if (peerDropdown) {
                peerDropdown.addEventListener('change', function() {
                    if (isSyncingDropdowns) return;
                    isSyncingDropdowns = true;
                    try {
                        const selectedIssuer = this.value;
                        // Sync large dropdown if issuer exists there
                        if (largeDropdown && selectedIssuer && getLargeIssuers().includes(selectedIssuer)) {
                            largeDropdown.value = selectedIssuer;
                        } else if (largeDropdown && !selectedIssuer) {
                            largeDropdown.value = '';
                        }
                        handleIssuerSelection(selectedIssuer);
                    } finally {
                        isSyncingDropdowns = false;
                    }
                });
            }
            if (largeDropdown) {
                largeDropdown.addEventListener('change', function() {
                    if (isSyncingDropdowns) return;
                    isSyncingDropdowns = true;
                    try {
                        const selectedIssuer = this.value;
                        const peerIssuers = getPeerIssuers();
                        let noneOption = peerDropdown ? peerDropdown.querySelector('option[value="NONE"]') : null;
                        if (peerDropdown) {
                            if (selectedIssuer && peerIssuers.includes(selectedIssuer)) {
                                peerDropdown.value = selectedIssuer;
                                // Hide NONE if present
                                if (noneOption) noneOption.style.display = 'none';
                            } else if (selectedIssuer) {
                                // Show NONE option and select it (no annotation)
                                if (!noneOption) {
                                    noneOption = document.createElement('option');
                                    noneOption.value = 'NONE';
                                    noneOption.textContent = 'NONE';
                                    peerDropdown.appendChild(noneOption);
                                }
                                noneOption.style.display = '';
                                peerDropdown.value = 'NONE';
                            } else {
                                peerDropdown.value = '';
                                // Hide NONE if present
                                if (noneOption) noneOption.style.display = 'none';
                            }
                        }
                        handleIssuerSelection(selectedIssuer);
                    } finally {
                        isSyncingDropdowns = false;
                    }
                });
            }
        });

        // 2. Handler for dropdown selection (applies to both)
       
        function handleIssuerSelection(selectedIssuer) {
            window.selectedIssuerKey = selectedIssuer || null;
            filterTableByCombined(window.selectedCategoryKey, window.selectedIssuerKey);
            regenerateChartsDebounced();
            // Also filter large dataset table if loaded
            if (typeof applyFiltersToLargeDataset === "function") {
                applyFiltersToLargeDataset();
            }
        }

        // 3. Populate the dropdowns with unique issuers
        function populateIssuerDropdownsPeer(data) {
            const container = document.getElementById('issuer-filter-container-peer');
            const dropdown = document.getElementById('issuerDropdownPeer');
            if (!container || !dropdown || !data || !data.length || !issuerCol) {
                if (container) container.style.display = 'none';
                return;
            }
            const issuers = [...new Set(data.map(row => row[issuerCol]).filter(Boolean))].sort();
            dropdown.innerHTML = '<option value="">All Issuers</option>';
            // Always add a hidden NONE option for sync logic
            let noneOption = document.createElement('option');
            noneOption.value = 'NONE';
            noneOption.textContent = 'NONE';
            noneOption.style.display = 'none';
            dropdown.appendChild(noneOption);
            issuers.forEach(issuer => {
                const option = document.createElement('option');
                option.value = issuer;
                option.textContent = issuer;
                dropdown.appendChild(option);
            });
            container.style.display = issuers.length === 0 ? 'none' : 'block';
        }
        function populateIssuerDropdownsLarge(data) {
            const container = document.getElementById('issuer-filter-container-large');
            const dropdown = document.getElementById('issuerDropdownLarge');
            if (!container || !dropdown || !data || !data.length || !largeIssuerCol) {
                if (container) container.style.display = 'none';
                return;
            }
            const issuers = [...new Set(data.map(row => row[largeIssuerCol]).filter(Boolean))].sort();
            if (issuers.length === 0) {
                container.style.display = 'none';
                return;
            }
            dropdown.innerHTML = '<option value="">All Issuers</option>';
            issuers.forEach(issuer => {
                const option = document.createElement('option');
                option.value = issuer;
                option.textContent = issuer;
                dropdown.appendChild(option);
            });
            container.style.display = 'block';
        }
        function getPeerIssuers() {
            const dropdown = document.getElementById('issuerDropdownPeer');
            return dropdown ? Array.from(dropdown.options).slice(1).map(opt => opt.value) : [];
        }
        function getLargeIssuers() {
            const dropdown = document.getElementById('issuerDropdownLarge');
            return dropdown ? Array.from(dropdown.options).slice(1).map(opt => opt.value) : [];
        }

        // 4. Wrap loadDatasetFromData and loadLargeDatasetFromData to populate dropdowns
        const original_loadDatasetFromData = loadDatasetFromData;
        loadDatasetFromData = function(parsedData, filename) {
            original_loadDatasetFromData.apply(this, arguments);
            populateIssuerDropdownsPeer(parsedData);
        };
        const original_loadLargeDatasetFromData = loadLargeDatasetFromData;
        loadLargeDatasetFromData = function(parsedData, filename) {
            original_loadLargeDatasetFromData.apply(this, arguments);
            populateIssuerDropdownsLarge(parsedData);
        };

        // 5. Wrap showAllRows to reset dropdowns
        const original_showAllRows = showAllRows;
        showAllRows = function() {
            original_showAllRows.apply(this, arguments);
            const peerDropdown = document.getElementById('issuerDropdownPeer');
            const largeDropdown = document.getElementById('issuerDropdownLarge');
            if (peerDropdown) {
                peerDropdown.value = "";
                // Hide NONE option if present
                const noneOption = peerDropdown.querySelector('option[value="NONE"]');
                if (noneOption) noneOption.style.display = 'none';
            }
            if (largeDropdown) largeDropdown.value = "";
        };

        // 6. Wrap handleChartClick to sync dropdowns with issuer chart clicks
        const original_handleChartClick = handleChartClick;
        handleChartClick = function(event, elements, labels, chartType) {
            original_handleChartClick.apply(this, arguments);
            if (chartType === 'issuer' && elements.length > 0) {
                const clickedIndex = elements[0].index;
                const selectedIssuer = labels[clickedIndex];
                const peerDropdown = document.getElementById('issuerDropdownPeer');
                const largeDropdown = document.getElementById('issuerDropdownLarge');
                const peerIssuers = getPeerIssuers();
                let noneOption = peerDropdown ? peerDropdown.querySelector('option[value="NONE"]') : null;
                if (peerDropdown && peerIssuers.includes(selectedIssuer)) {
                    peerDropdown.value = selectedIssuer;
                    if (noneOption) noneOption.style.display = 'none';
                } else if (peerDropdown && selectedIssuer) {
                    if (!noneOption) {
                        noneOption = document.createElement('option');
                        noneOption.value = 'NONE';
                        noneOption.textContent = 'NONE';
                        peerDropdown.appendChild(noneOption);
                    }
                    noneOption.style.display = '';
                    peerDropdown.value = 'NONE';
                }
                if (largeDropdown && getLargeIssuers().includes(selectedIssuer)) largeDropdown.value = selectedIssuer;
            }
        };

        // --- END OF NON-INVASIVE INTEGRATION ---
    </script>
</body>
</html>
